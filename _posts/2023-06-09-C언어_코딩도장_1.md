---
layout: single
title:  "[C언어_코딩도장] 1장 : 기초문법 & 자료형"
categories: coding
tag: [C언어_코딩도장]
toc: true
author_profile: true
published: false # 저작권
---

<head>
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>



해당 게시글은 [C언어_코딩도장](https://dojang.io/) 을 공부하며 정리한 글입니다.(Unit1~11)


[목차]  

> **출력**  

> ㄴ printf. 출력방법 2가지(단순, 서식이용)  

> ㄴ 주의점

> 

> **입력**  

> ㄴ scanf  

> ㄴ 주의점  

>

> **정수자료형**  

> ㄴ 종류  

> ㄴ char  

> ㄴ int  

> ㄴ 정수자료형 출력  


---

# 출력


**출력방법 2가지**

- 단순출력 : prinf(값)

- 서식출력 : printf(서식, 값1, 값2, ...);

  - 문자열 서식 지정자 : %s(strinf)

  - 정수 서식 지정자 : %d(decimal, 십진수), %i(int)

    - i의 경우 10진수 뿐만 아니라 8, 12진수 등 을 다 포함한다.(접미사에 따라 진수를 다르게 인식)

  - 입력되는 문자열을 "매개변수"라고 부른다.

  - (성공하면 출력한 문자열의 길이를 반환, 실패하면 음수를 반환)



```python
#include <stdio.h> // 헤더파일을 포함한다. stdio(standard io/표준입출력)

int main() # 메인함수. 반환하는 값이 정수이기에 int를 명시.
{
    printf("Hello, world!\n"); # print formated(포멧에 따라 출력), \n : new line(여기서 \는 제어자).
    printf("%s\n", "Hello, World!"); # "%s"에 다음에 오는 문자열이 들어가 출력된다.

    return 0; # 앞에서 int를 반환한다고 했으니, 0(int)를 반환.
}
```

**서식출력 주의점1(공란)**

- %s 하나일 때 2개를 입력하면 문제 없음.

- 그러나 %s가 2개일 때 1개를 입력하면 뒤의 %s에는 쓰레기값이 들어간다.(보안상 좋지 않음)

  - 공란에 "?"가 출력됨



```python
printf("%s\n", "Hello, World!", "Hello, World!"); # Hello, World!

printf("%s %s\n", "Hello, World!"); # Hello, World! ?
```

**서식출력 주의점2(특수문자)**

- %를 출력하고 싶으면 포멧에 "%%"를 입력

- 포멧란에 "%"하나만 입력하면 생략됨

- \\(제어자)와 같은 특수기호도 마찬가지로



```python
printf("10%%\n"); # 10%

printf("10%%%\n"); # 10%

printf("주의주의 %s%% %s%\n", "10","20"); # 주의주의 10% 20
```

**서식출력 주의점3(개행)**

- Python의 경우 print시, 디폴트가 개행이된다.(end=''으로 하면 한줄로 이어서)

- C의 경우, 서식출력을 위해 printf을 사용하기 때문에 개행을 위해 "\n"을 사용

  > printf를 사용할 때마다 \n과 ; 을 사용해서 마무리하는 것으로 습관을 들이자.


<br><br><br><br>


---

# 입력


**c언어에서는 입력을 위해 일반적으로 scanf()를 사용한다.**

- `scanf("서식", 입력1, 입력2, ...)`

  - 입력값이 배열이 아닌 일반 변수인 경우, 앞에 `&`를 적어줘야한다.

    - %d: 정수

    - %f: 실수

    - %c: 문자

  - 배열은 포인터처럼 주소값을 가지고 있음으로 &가 불필요.



**Visual Studio에서 입력이 필요한 코드를 실행할 때**  

- `#define _CRT_SECURE_NO_WARNINGS`를 #include 전에 실행!

- scanf 보안 경고로 인한 컴파일 에러 방지

- 위 코드가 없으면 컴파일 에러가 나는 이유는?

  - scanf는 나온 지 오래된 함수라 입력 값의 길이를 설정할 수가 없음.

  - 따라서 보안에 취약하기 때문에 Visual Studio에서는 사용하지 말라는 경고가 출력되고 컴파일 에러가 발생

  - 그래서 보안을 위한 scanf_s 가 존재.(but이는 c++ 함수임)



```python
int num1;
char s1[10]; # 9개의 문자를 저장할수 있는 배열

scanf("%d", &num1); # 일반 변수일 때는 변수 앞에 &를 붙임
scanf("%s", s1); # 배열은 앞에 &을 붙이지 않음
```

<br>


**문자열 입력 주의점1(배열길이)**

- 문자열의 길이가 (배열의 길이 - 1)을 넘지 않도록 한다.

- 문자열 맨 마지막에는 보이지 않는 NULL값이 저장되어 있다.


<img width="431" alt="image" src="https://github.com/Jyassmin/Causality_Extraction/assets/88031549/d868ed38-57b0-4067-829c-e53b646a4ce2">


<br>


**문자열 입력 주의점2(공백)**

- 입력된 문자열에 공백이 있다면, 배열에는 공백 직전까지만 저장

  - 중간에 공백이 있는 "Hello, world!"를 입력하면 Hello, 까지만 저장됨

- but, "%[^\n]s"를 사용한다면 공백까지 배열에 저장!



```python
char s1[20];
scanf("%s", s1); # 입력 : "Hello, World!"
printf("%s", s1); # 출력 : Hello,

char s2[20];
scanf("%[^\n]s", s2); # 입력 : "Hello, World!"
printf("%s", s2); # 출력 : "Hello, World!"
```

<br>


**문자 입력을 위한 다른방법**  

scanf가 아닌 `getchar()`를 사용하여 문자 하나를 입력받을 수 있다.  

마찬가지로 `putchar()`를 사용해서 문자 하나를 출력할 수 있다.



ex) char c1 = getchar();


<br>


**실수형(double) 입력 주의점**  

double의 경우 printf에서 사용할 때는 %f를 사용한다.  

그러나 scanf를 통해 입력할 때는 `%lf`를 사용!  

(long double의 경우에는 scanf에서는 `%Lf`사용)


<br>


서식을 사용한 입력 방법으로 scanf()가 있었다.  

서식없이 입력 받는 방법으로는 getchar()가 존재.  

(input()이라는 함수를 통해 입력값을 받아오는 python과 비슷.) 



```python
int c1 = getchar(); # 문자를 입력받음
printf("%d\n", c1); # 출력
```

<br>


**fflush**란?  

표준 입력 함수를 통해 데이터를 받을 때, 효율적인 처리를 위해 버퍼에 저장한 후 하나씩 처리한디.  

그래서 버퍼에 데이터가 남게 되면 정상적인 입출력을 하지 못하기 때문에 `fflush()`함수를 이용하여 버퍼에 있는 데이터를 비워줘야 한다.


입력이 다음과 같이 주어질 때, 마지막 두개의 정수를 받아오는 방법은?  

입력 : 두 수를 입력하시오. 3 5



```python
printf("두 수를 입력하시오. ");
fflush(stdout);
scanf("%d %d", &a, &b);
```

<br><br><br><br>


---

# 정수 자료형


HW에서 정수는 ALU, 실수는 FPU로 계산이된다.


## 0. 종류


정수 자료형은 크게 char, int가 있으며 앞에  

부호 키워드(signed, unsigned)와 크기(short, long)를 붙여서 특성을 정의할 수 있음.

- signed : 부호 있는 정수 (-),0,(+) 전부 다 포함.(보통 signed 키워드는 생략)

- unsigned : 부호 없는 정수 0,(+).

  - 0부터 시작한다.


<img width="413" alt="image" src="https://github.com/Jyassmin/Causality_Extraction/assets/88031549/0f9cd4c6-5e3c-4f0c-88a1-fea99ae8fe3a">


<img width="497" alt="image" src="https://github.com/Jyassmin/Causality_Extraction/assets/88031549/9655c2b7-e98d-4540-9e9e-eddf2ddd2b91">


<br>


**자료형의 크기(byte) 구하기**

- byte는 bit의 8배임

- 사용법

  - sizeof 자료형;

  - sizeof (자료형);

  - sizeof (표현식);


<br><br>


## 1. char  


- bit : 8  

- range : 256(2^8)

  - signed char : -128~127

  - unsigned char : 0~255


<br><br>


## 2. int


int는 기본(long) 32비트이며, short int는 16비트, long long int는 64비트로 나뉘어진다.  

헷갈리니 short int, int, long long int 3가지로 사용하자.(long int 사용x)


### 1) short int

- bit : 16

- range : 65536(2^16)

  - signed short int : -32,768 ~ 32,767

  - unsigned short int : 0~65535


### 2) (long) int

int는 "long"이 생략된 것이다. 라고 생각하자  

사실 64bit운영체제에서는 long형이 64bit로 사용되는 경우가 있다.  

(그래서 "int"와 "long"이 다르긴 하지만 헷갈리니 이렇게 먼저 이해하자)


- bit : 32

- range : 4,294,967,296(2^32) # 약 43억

  - signed (long) int : -21억 ~ 21억

  - unsigned (long) int : 약 43억


### 3) long long int


- bit : 64

- range : 제일 큰 정수 자료형(위사진 참고)

  - signed long long int

  - unsigned long long int


<br><br>


## 3. Signed. unsigned


### 1) signed


- %d: decimal(10진수) / char, short, int

- %ld: long decimal

- %lld: long long decimal



```python
char num1 = -10;           # 1바이트 
short num2 = 30000;        # 2바이트
int num3 = -1234567890;    # 4바이트 
long num4 = 1234567890;    # 4바이트 
long long num5 = -1234567890123456789;     # 8바이트

# char, short, int는 %d로 출력하고 long은 %ld, long long은 %lld로 출력
printf("%d %d %d %ld %lld\n", num1, num2, num3, num4, num5);
# -10 30000 -1234567890 1234567890 -1234567890123456789
```

<br>


### 2) unsigned


- %u: unsigned / unsigned char, short, int

- %lu: long unsigned

- %llu: long long unsigned



```python
unsigned char num1 = 200; # 1바이트 
unsigned short num2 = 60000; # 2바이트 
unsigned int num3 = 4123456789; # 4바이트 
unsigned long num4 = 4123456789; # 4바이트 
unsigned long long num5 = 12345678901234567890; # 8바이트 

printf("%u %u %u %lu %llu\n", num1, num2, num3, num4, num5);
# 200 60000 4123456789 4123456789 12345678901234567890
```

<br>


## 4. 오버플로우, 언더플로우


**정수 자료형에서 저장할 수 있는 범위를 넘어서면 어떻게 될까?**

- 오버플로우 : 자료형의 최댓값 보다 커져버리면 최솟값부터 증가

- 언더플로우 : 자료형의 작은값 보다 작아져버리면 최대값에서 감소  



> 자료형의 범위는 직선이 아닌 환형으로 이어져있다.



```python
# 오버플로우 예시
char num1 = 128; # char의 최댓값 127보다 큰 수를 할당
unsigned char num2 = 256; # unsigned char의 최댓값 255보다 큰 수를 할당

printf("%d %u\n", num1, num2);    # -128 0 / 저장할 수 있는 범위를 넘어서므로 최솟값부터 다시 시작
```

<img width="506" alt="image" src="https://github.com/Jyassmin/Causality_Extraction/assets/88031549/232ae264-c776-48fd-a7c4-cc3e6aa46e83">


<br>


## 5. 자료형의 최소값과 최댓값 구하기

- 헤더파일명 : #include **<limits.h>** <=> 실수형은 <float.h>

  - 자료형의 최댓값과 최솟값이 정의된 헤더 파일

- 이후 아래 CHAR_MIN와 같이 변수처럼 그냥 사용하면 됨 


<img width="230" alt="image" src="https://github.com/Jyassmin/Causality_Extraction/assets/88031549/9d2434e2-cc50-472d-91d0-6ba5abc86248">



<br>


## 6. 크기가 표시된 정수 자료형 사용하기


운영체제가 발전하면서 정수 자료형의 크기도 그때 그때 달라졌다.  

그래서 정수 자료형 이름은 많은 혼란을 가져왔고 C99 표준부터는 stdint.h 헤더 파일이 추가되어,  

크기가 정의된 자료형을 사용할 수 있다.


- 헤더파일명 : #include **<stdint.h>**  



- signed

  - int8_t  ->  char 

  - int16_t  ->  short

  - int32_t  ->  int, long

  - int64_t  -> long long

<br>

<br>



- unsigned

  - uint8

  - uint16_t

  - uint32_t

  - uint64_t



```python
#include <stdio.h>
#include <stdint.h>    // 크기별로 정수 자료형이 정의된 헤더 파일

int main()
{
    int8_t num1 = -128;                    // 8비트(1바이트) 크기의 부호 있는 정수형 변수 선언
    int16_t num2 = 32767;                  // 16비트(2바이트) 크기의 부호 있는 정수형 변수 선언 
    int32_t num3 = 2147483647;             // 32비트(4바이트) 크기의 부호 있는 정수형 변수 선언
    int64_t num4 = 9223372036854775807;    // 64비트(8바이트) 크기의 부호 있는 정수형 변수 선언

    // int8_t, int16_t, int32_t는 %d로 출력하고 int64_t는 %lld로 출력
    printf("%d %d %d %lld\n", num1, num2, num3, num4); // -128 32767 2147483647 9223372036854775807

    uint8_t num5 = 255;                      // 8비트(1바이트) 크기의 부호 없는 정수형 변수 선언
    uint16_t num6 = 65535;                   // 16비트(2바이트) 크기의 부호 없는 정수형 변수 선언
    uint32_t num7 = 4294967295;              // 32비트(4바이트) 크기의 부호 없는 정수형 변수 선언
    uint64_t num8 = 18446744073709551615;    // 64비트(8바이트) 크기의 부호 없는 정수형 변수 선언

    // uint8_t, uint16_t, uint32_t는 %u로 출력하고 uint64_t는 %llu로 출력
    printf("%u %u %u %llu\n", num5, num6, num7, num8); // 255 65535 4294967295 18446744073709551615

    return 0;
}
```

<br><br><br><br>


---

# 실수 자료형


정수에서는 int가 기본 자료형이었다면, 실수에서는 double이 기본 자료형이다.(운영체제에 따라 float일 수 있음)  

그래서 double이 아닌 float를 사용할 때에는 1.23f 와 같이 'f'를 명시해줘야한다.


<br>


## 1. 종류 및 크기


[유효자릿수]  

 : 실수를 일정 자릿수만큼만 표현

- 만약 유효자릿수가 7이라면 0.123456789는 반올림하여 0.123457로 표시됩니다.

- 즉, 정수 부분 1자리와 소수 부분 6자리로 7자리가 표시됩니다.


[bit]  

정수 자료형에서 제일 작은 char의 경우 8bit였다.  

그러나 실수형에서는 가장 작은것이 32비트.(16아래는 없다.)



[부동소수점 방식]  

실수를 메모리 또는 디스크에 저장하는 방식


<img width="503" alt="image" src="https://github.com/Jyassmin/Causality_Extraction/assets/88031549/e516fbe5-f303-4683-a8ca-41b54969474e">



<br><br>


## 2. 지수 표기법


[지수표기]  

%f 사용 : 부동소수점(floating point)의 약어

- 1.2345는 12345e-4 와 같다.

- 12345는 1.2345e5 와 같다.


[출력]  

%f :float와 double

%lf : long double (%Lf도 가능)  





[지수표기 출력]  

%e: 지수 표기법(exponential notation)의 약어 

%le: long exponential notation



```python
#include <stdio.h>

int main()
{
    float num1 = 3.e5f;             // 지수 표기법으로 300000을 표기
                                    // float는 숫자 뒤에 f를 붙임
 
    double num2 = -1.3827e-2;       // 지수 표기법으로 -0.013827을 표기
                                    // double은 숫자 뒤에 아무것도 붙이지 않음

    long double num3 = 5.21e+9l;    // 지수 표기법으로 5210000000을 표기
                                    // long double은 숫자 뒤에 l을 붙임

    // float와 double은 %f로 출력, long double은 %Lf로 출력
    printf("%f %f %Lf\n", num1, num2, num3); // 300000.000000 -0.013827 5210000000.000000

    // 지수 표기법으로 출력할 때는 float와 double은 %e로 출력, long double은 %Le로 출력
    printf("%e %e %Le\n", num1, num2, num3); // 3.000000e+05 -1.382700e-02 5.210000e+09

    return 0;
}
```

<br>


## 3. 실수 자료형의 최소값과 최댓값 구하기

- 헤더파일명 : include **<float.h>** <-> 정수형은 <limits.h>

  - 실수 자료형의 최댓값과 최솟값이 정의된 헤더 파일

- 이후 아래 FLT_MIN과 같이 변수처럼 그냥 사용하면 됨 



```python
int main()
{
    float num1 = FLT_MIN;           // float의 양수 최솟값
    float num2 = FLT_MAX;           // float의 양수 최댓값
    double num3 = DBL_MIN;          // double의 양수 최솟값
    double num4 = DBL_MAX;          // double의 양수 최댓값
    long double num5 = LDBL_MIN;    // long double의 양수 최솟값
    long double num6 = LDBL_MAX;    // long double의 양수 최댓값

    printf("%.40f %.2f\n", num1, num2);    // 0.0000000000000000000000000000000000000118
                                           // 340282346638528859811704183484516925440.00

    printf("%e %e\n", num3, num4);         // 2.225074e-308 1.797693e+308
    printf("%Le %Le\n", num5, num6);       // 2.225074e-308 1.797693e+308
 
    return 0;
}
```

<br>


## 4. 오버플로우


정수형에서는 경계값 보다 적거나 크게 빼고 더하여 오버,언더 플로우가 발생하였음.  

실수형에서도 위와같이 발생할 수 있지만, 실수형에서는 곱하고 나누는 과정에서 더욱 조심할 것!


정수형과 다르게 실수의 오버,언더 플로우는 출력값이 다르다.  

오버는 inf값으로, 언더는 0(or 쓰레기값)



```python
#include <stdio.h>
#include <float.h>    // 실수 자료형의 양수 최솟값, 최댓값이 정의된 헤더 파일

int main()
{
    float num1 = FLT_MIN;    // float의 양수 최솟값
    float num2 = FLT_MAX;    // float의 양수 최댓값

    // float의 양수 최솟값을 100000000.0으로 나누면 아주 작은 수가 되면서 언더플로우 발생
    num1 = num1 / 100000000.0f;

    // float의 양수 최댓값에 1000.0을 곱하면 저장할 수 있는 범위를 넘어서므로 오버플로우 발생
    num2 = num2 * 1000.0f;

    printf("%e %e\n", num1, num2);    // 0.000000e+00 inf: 실수의 언더플로우는 0
                                      // 오버플로우는 무한대가 됨

    return 0;
}
```

<br><br><br><br>


---

# 문자 자료형


## 1. Char

정수 또는 하나의 문자를 담을 수 있다.  

그러나 정수를 문자로(%c) 출력할 수 있고, 문자를 (%d) 정수로도 출력할 수 있다.  

(java에서는 byte(가장 작은 정수형)과 char가 구분됨)


<br>


**char는 signed일까? unsigned일까?**  

담는 것이 정수냐 문자이냐에 따라 다르다.  

- char에 정수를 담으면 char는 'signed' char이다.(정수에서는 이 규칙을 따름)  

- 그러나, char에 문자를 담으면 이것은 'unsigned'이다!

- 왜냐, (확장) 아스키 코드는 0~255까지 있다. 그렇기에 이를 위해 기본이 unsigned이다. 


<img width="359" alt="image" src="https://github.com/Jyassmin/Causality_Extraction/assets/88031549/e718b4e3-45a7-4a13-ae8b-7ce40273b8ac">



```python
char a = 'A';
char b = 'B';

printf("%c %d\n", a, a); # A 65
printf("%c %d\n", b, b); # B 66
```


```python
char c1 = '0';    // 문자 0을 저장
char c2 = 0;      // 숫자 0을 저장

printf("%c %d\n", c1, c1);    // 0 48 : 문자 0과 문자 0의 ASCII 코드안 48이 출력됨.
printf("%c %d\n", c2, c2);    // 0: ASCII 코드 0은 널문자이므로 아무것도 출력되지 않음(공백조차 없음). 따라서 ' 0'이 출력됨.
```

<br><br>


## 2. 문자 연산


문자는 ASCII 코드 규칙에 의해 정수로 저장되므로 정수처럼 덧셈, 뺄셈이 가능하다.

- 다만 그 결과는 %c(문자), %d(십진수)에 따라 달라진다.



```python
printf("%c %d\n", 'a' + 1, 'a' + 1);    // b 98: a는 ASCII 코드값 97이고, 
                                        // 97에 1을 더하여 98이 되었으므로 b가 출력됨

printf("%c %d\n", 97 + 1, 97 + 1);      // b 98: ASCII 코드값 97에 1을 더하여 98이 되었으므로 
                                        // b가 출력됨
```

<br><br>


## 3. 제어 문자


문자 자료형에는 "\n"(개행)과 같은 제어문자도 저장할 수 있다.  

이를 %c를 통해 출력하며 원래의 기능을 수행할 수 있음.



```python
char c1 = 'a';           // 문자 a 할당
char c2 = 'b';           // 문자 b 할당 
char lineFeed = '\n';    // 제어 문자 \n 할당

printf("%c%c%c%c", c1, lineFeed, c2, lineFeed);    // 제어 문자도 %c로 출력할 수 있음

#----
# a
# b
```

**제어문자 주의점**  

'\n', '\t', '\r' 등과 같은 제어자는 2개의 문자로 구성되어있지만, 실제로 컴퓨터가 인식하는 것은 하나의 문자이다.  

그렇기 때문에 큰 따옴표가 아닌, 작은 따옴표를 사용해야한다.

<br>



[*참고]

- '\n' : New line(= Line Feed, 개행)

- '\t' : Tab(7개의 공백 생성)

- '\r' : Return(줄의 끝에서 시작 위치로 되돌아감. 출력이 없어짐)


<br><br><br><br>


---

# 상수


상수란? 변하지 않는 값을 의미한다.  

상수와 리터럴을 혼동되게 부르기 때문에, 리터럴과 함께 알아보자.


## 1. 상수  

상수(const)는 처음 선언할 때만 값을 할당할 수 있으며 그다음부터는 값을 바꿀 수 없다.  

또한 변수처럼 리터럴이 저장된 공간.

- `const` (자료형) (상수명)

- (자료형) const (상수명) 도 가능.(잘사용x)



```python
//         ↓ 상수
const int con1 = 10;
//               ↑ 리터럴
```



## 2. 리터럴


**리터럴(literal)이란?**  

"문자 그대로"라는 뜻.C 언어에서는 값 그 자체를 뜻합니다.

- 정수 리터럴

- 실수 리터럴

- 문자 리터럴

- 문자열 리터럴

- x진 정수 리터럴 등


> 우리가 입력하는 숫자, 문자, 문자열 모든 것이 다 리터럴임.



```python
    printf("%d\n", 10);                 // 10: 정수 리터럴
    printf("%f\n", 0.1f);               // 0.100000: 실수 리터럴
    printf("%c\n", 'a');                // a: 문자 리터럴
    printf("%s\n", "Hello, world!");    // Hello, world!: 문자열 리터럴
```


```python
printf("%d\n", 19);        // 19: 10진 정수 리터럴
printf("0%o\n", 017);      // 017: 8진 정수 리터럴
printf("0x%X\n", 0x1F);    // 0x1F: 16진 정수 리터럴
```

끝!

